from classes.escape_room import EscapeRoom
from classes.player import Player
from classes.player_group import PlayerGroup
from classes.visit import check_rating_value
from object_plus.object_plus_plus import ObjectPlusPlus
from object_plus.roles import Role, RoleConstraint, first_or_unknown


class Recommendation(ObjectPlusPlus):
    def __init__(self, escape_room: EscapeRoom, expected_rating: int, generated_by_user: bool):
        check_rating_value(expected_rating)
        self.generated_by_user = generated_by_user
        super().__init__()
        self.add_link(Role.escape_room, escape_room)

    @staticmethod
    def get_extent(class_name=None):
        return ObjectPlusPlus.get_extent(Recommendation)

    def send_to(self, name: str):
        if self.generated_by_user:
            raise NotImplementedError("Recommendation generated by user cannot be send!")
        print(f"Recommendation sent to user {name}")


class PlayerRecommendation(Recommendation):
    """
    Class represents a recommendation of the Escape Room for the specific player

    Attributes:
    ----------
    expected_rating : int
        expected rating of the escape room for the user in the scale 1-10
    """

    def __init__(self, escape_room: EscapeRoom, user: Player, expected_rating: int, generated_by_user: bool):
        if user is None:
            raise ValueError("Recommendation cannot exist without the User!")
        check_rating_value(expected_rating)
        self.generated_by_user = generated_by_user
        super().__init__(escape_room, expected_rating, generated_by_user)
        user.add_part(Role.recommendation, Role.player, self)

    @classmethod
    def get_role_constraints(cls):
        return {
            Role.player: RoleConstraint(1, Role.recommendation),
            Role.escape_room: RoleConstraint(1, Role.recommendation)
        }

    def __str__(self) -> str:
        player = first_or_unknown(self, Role.player)
        escape_room = first_or_unknown(self, Role.escape_room)
        return f'Recommendation: {player} for {escape_room}'

    def send(self):
        self.send_to(first_or_unknown(self, Role.player))


class GroupRecommendation(Recommendation):

    def __init__(self, escape_room: EscapeRoom, group: PlayerGroup, expected_rating: int, generated_by_user: bool):
        if group is None:
            raise ValueError("Recommendation cannot exist without the Group!")
        check_rating_value(expected_rating)
        self.generated_by_user = generated_by_user
        super().__init__(escape_room, expected_rating, generated_by_user)
        group.add_part(Role.recommendation, Role.group, self)

    @classmethod
    def get_role_constraints(cls):
        return {
            Role.group: RoleConstraint(1, Role.recommendation),
            Role.escape_room: RoleConstraint(1, Role.recommendation)
        }

    def __str__(self) -> str:
        group = first_or_unknown(self, Role.group)
        escape_room = first_or_unknown(self, Role.escape_room)
        return f'Recommendation: {group} for {escape_room}'

    def send(self):
        for player in self.get_links(Role.group)[0].get_links(Role.player):
            self.send_to(player.get_user().username)
